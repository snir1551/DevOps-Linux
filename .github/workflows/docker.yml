name: Docker CI/CD Pipeline

on:
  push:
    branches:
      - main

jobs:
  build-test-deploy:
    runs-on: ubuntu-latest

    outputs:
      webapp_health_status: ${{ steps.wait_for_health.outputs.health_status }}

    steps:
    - name: Checkout Code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Prepare .env file for Docker Compose
      run: |
        echo "MONGO_INITDB_ROOT_USERNAME=${{ secrets.MONGO_USERNAME }}" > ./week6_practice/.env
        echo "MONGO_INITDB_ROOT_PASSWORD=${{ secrets.MONGO_PASSWORD }}" >> ./week6_practice/.env
        echo "PORT=3000" >> ./week6_practice/.env
        echo "MONGO_HOST=mongodb" >> ./week6_practice/.env

    - name: Bring up services with Docker Compose
      run: |
        docker compose -f ./week6_practice/docker-compose.yml up -d

    - name: Wait for Webapp to be healthy
      id: wait_for_health
      run: |
        echo "Waiting for webapp container to be healthy..."
        timeout_seconds=300
        start_time=$(date +%s)

        FINAL_HEALTH_STATUS="unknown"

        while true; do
          current_status=$(docker inspect webapp --format '{{.State.Health.Status}}' 2>/dev/null || echo "not_found")

          if [ "$current_status" == "healthy" ]; then
            echo "Webapp is healthy!"
            FINAL_HEALTH_STATUS="healthy"
            break
          elif [ "$current_status" == "not_found" ]; then
            echo "Webapp container not found yet. Retrying..."
          else
            echo "Webapp status: $current_status. Waiting..."
          fi

          current_time=$(date +%s)
          elapsed_time=$((current_time - start_time))

          if [ "$elapsed_time" -ge "$timeout_seconds" ]; then
            echo "Webapp did not become healthy within the timeout period."
            echo "Dumping webapp logs for debugging:"
            docker logs webapp
            FINAL_HEALTH_STATUS="unhealthy"
            exit 1
          fi

          sleep 10
        done

        echo "health_status=$FINAL_HEALTH_STATUS" >> "$GITHUB_OUTPUT"

    - name: Send Slack Notification
      if: always()
      uses: slackapi/slack-github-action@v1.26.0
      with:
        payload: |
          {
            "text": "Deployment Update for `${{ github.repository }}`",
            "blocks": [
              {
                "type": "section",
                "text": {
                  "type": "mrkdwn",
                  "text": ":rocket: *Deployment Status: ${{ job.status == 'success' && ':white_check_mark: Success' || ':x: Failure' }}*"
                }
              },
              {
                "type": "section",
                "fields": [
                  { "type": "mrkdwn", "text": "*Repository:*\n`${{ github.repository }}`" },
                  { "type": "mrkdwn", "text": "*Branch:*\n`${{ github.ref_name }}`" },
                  { "type": "mrkdwn", "text": "*Commit:*\n<${{ github.server_url }}/${{ github.repository }}/commit/${{ github.sha }}|${{ github.sha | truncate(7, '') }}>" },
                  { "type": "mrkdwn", "text": "*Triggered by:*\n`${{ github.actor }}`" },
                  { "type": "mrkdwn", "text": "*Workflow Run:*\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|#${{ github.run_number }}>" },
                  { "type": "mrkdwn", "text": "*Webapp Health:*\n`${{ steps.wait_for_health.outputs.health_status }}`" }
                ]
              }
            ]
          }
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL_Docker }}

    - name: Clean up Docker Compose services
      if: always()
      run: docker compose -f ./week6_practice/docker-compose.yml down -v
